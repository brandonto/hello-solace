//*****************************************************************************
//
// adc.c - Driver for the ADC.
//
// Copyright (c) 2005-2016 Texas Instruments Incorporated.  All rights reserved.
// Software License Agreement
// 
//   Redistribution and use in source and binary forms, with or without
//   modification, are permitted provided that the following conditions
//   are met:
// 
//   Redistributions of source code must retain the above copyright
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the
//   documentation and/or other materials provided with the  
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// 
// This is part of revision 2.1.3.156 of the Tiva Peripheral Driver Library.
//
//*****************************************************************************

//*****************************************************************************
//
//! \addtogroup adc_api
//! @{
//
//*****************************************************************************

#include <stdbool.h>
#include <stdint.h>
#include "inc/hw_adc.h"
#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_sysctl.h"
#include "driverlib/adc.h"
#include "driverlib/debug.h"
#include "driverlib/interrupt.h"

//*****************************************************************************
//
//! Configures the trigger source and priority of a sample sequence.
//!
//! \param ui32Base is the base address of the ADC module.
//! \param ui32SequenceNum is the sample sequence number.
//! \param ui32Trigger is the trigger source that initiates the sample
//! sequence; must be one of the \b ADC_TRIGGER_* values.
//! \param ui32Priority is the relative priority of the sample sequence with
//! respect to the other sample sequences.
//!
//! This function configures the initiation criteria for a sample sequence.
//! Valid sample sequencers range from zero to three; sequencer zero captures
//! up to eight samples, sequencers one and two capture up to four samples,
//! and sequencer three captures a single sample.  The trigger condition and
//! priority (with respect to other sample sequencer execution) are set.
//!
//! The \e ui32Trigger parameter can take on the following values:
//!
//! - \b ADC_TRIGGER_PROCESSOR - A trigger generated by the processor, via the
//!                              ADCProcessorTrigger() function.
//! - \b ADC_TRIGGER_COMP0 - A trigger generated by the first analog
//!                          comparator; configured with ComparatorConfigure().
//! - \b ADC_TRIGGER_COMP1 - A trigger generated by the second analog
//!                          comparator; configured with ComparatorConfigure().
//! - \b ADC_TRIGGER_COMP2 - A trigger generated by the third analog
//!                          comparator; configured with ComparatorConfigure().
//! - \b ADC_TRIGGER_EXTERNAL - A trigger generated by an input from the Port
//!                             B4 pin.  Note that some microcontrollers can
//!                             select from any GPIO using the
//!                             GPIOADCTriggerEnable() function.
//! - \b ADC_TRIGGER_TIMER - A trigger generated by a timer; configured with
//!                          TimerControlTrigger().
//! - \b ADC_TRIGGER_PWM0 - A trigger generated by the first PWM generator;
//!                         configured with PWMGenIntTrigEnable().
//! - \b ADC_TRIGGER_PWM1 - A trigger generated by the second PWM generator;
//!                         configured with PWMGenIntTrigEnable().
//! - \b ADC_TRIGGER_PWM2 - A trigger generated by the third PWM generator;
//!                         configured with PWMGenIntTrigEnable().
//! - \b ADC_TRIGGER_PWM3 - A trigger generated by the fourth PWM generator;
//!                         configured with PWMGenIntTrigEnable().
//! - \b ADC_TRIGGER_ALWAYS - A trigger that is always asserted, causing the
//!                           sample sequence to capture repeatedly (so long as
//!                           there is not a higher priority source active).
//!
//! When \b ADC_TRIGGER_PWM0, \b ADC_TRIGGER_PWM1, \b ADC_TRIGGER_PWM2 or
//! \b ADC_TRIGGER_PWM3 is specified, one of the following should be ORed into
//! \e ui32Trigger to select the PWM module from which the triggers will be
//! routed for this sequence:
//!
//! - \b ADC_TRIGGER_PWM_MOD0 - Selects PWM module 0 as the source of the
//!                             PWM0 to PWM3 triggers for this sequence.
//! - \b ADC_TRIGGER_PWM_MOD1 - Selects PWM module 1 as the source of the
//!                             PWM0 to PWM3 triggers for this sequence.
//!
//! Note that not all trigger sources are available on all Tiva family
//! members; consult the data sheet for the device in question to determine the
//! availability of triggers.
//!
//! The \e ui32Priority parameter is a value between 0 and 3, where 0
//! represents the highest priority and 3 the lowest.  Note that when
//! programming the priority among a set of sample sequences, each must have
//! unique priority; it is up to the caller to guarantee the uniqueness of the
//! priorities.
//!
//! \return None.
//
//*****************************************************************************
void
ADCSequenceConfigure(uint32_t ui32Base, uint32_t ui32SequenceNum,
                     uint32_t ui32Trigger, uint32_t ui32Priority)
{
    uint32_t ui32Gen;

    //
    // Check the arugments.
    //
    ASSERT((ui32Base == ADC0_BASE) || (ui32Base == ADC1_BASE));
    ASSERT(ui32SequenceNum < 4);
    ASSERT(((ui32Trigger & 0xF) == ADC_TRIGGER_PROCESSOR) ||
           ((ui32Trigger & 0xF) == ADC_TRIGGER_COMP0) ||
           ((ui32Trigger & 0xF) == ADC_TRIGGER_COMP1) ||
           ((ui32Trigger & 0xF) == ADC_TRIGGER_COMP2) ||
           ((ui32Trigger & 0xF) == ADC_TRIGGER_EXTERNAL) ||
           ((ui32Trigger & 0xF) == ADC_TRIGGER_TIMER) ||
           ((ui32Trigger & 0xF) == ADC_TRIGGER_PWM0) ||
           ((ui32Trigger & 0xF) == ADC_TRIGGER_PWM1) ||
           ((ui32Trigger & 0xF) == ADC_TRIGGER_PWM2) ||
           ((ui32Trigger & 0xF) == ADC_TRIGGER_PWM3) ||
           ((ui32Trigger & 0xF) == ADC_TRIGGER_ALWAYS) ||
           ((ui32Trigger & 0x30) == ADC_TRIGGER_PWM_MOD0) ||
           ((ui32Trigger & 0x30) == ADC_TRIGGER_PWM_MOD1));
    ASSERT(ui32Priority < 4);

    //
    // Compute the shift for the bits that control this sample sequence.
    //
    ui32SequenceNum *= 4;

    //
    // Set the trigger event for this sample sequence.
    //
    HWREG(ui32Base + ADC_O_EMUX) = ((HWREG(ui32Base + ADC_O_EMUX) &
                                     ~(0xf << ui32SequenceNum)) |
                                    ((ui32Trigger & 0xf) << ui32SequenceNum));

    //
    // Set the priority for this sample sequence.
    //
    HWREG(ui32Base + ADC_O_SSPRI) = ((HWREG(ui32Base + ADC_O_SSPRI) &
                                      ~(0xf << ui32SequenceNum)) |
                                     ((ui32Priority & 0x3) <<
                                      ui32SequenceNum));

    //
    // Set the source PWM module for this sequence's PWM triggers.
    //
    ui32Gen = ui32Trigger & 0x0f;
    if(ui32Gen >= ADC_TRIGGER_PWM0 && ui32Gen <= ADC_TRIGGER_PWM3)
    {
        //
        // Set the shift for the module and generator
        //
        ui32Gen = (ui32Gen - ADC_TRIGGER_PWM0) * 8;
        
        HWREG(ADC0_BASE + ADC_O_TSSEL) = ((HWREG(ADC0_BASE + ADC_O_TSSEL) &
                                          ~(0x30 << ui32Gen)) |
                                          ((ui32Trigger & 0x30) << ui32Gen));
    }
}

//*****************************************************************************
//
// Close the Doxygen group.
//! @}
//
//*****************************************************************************
